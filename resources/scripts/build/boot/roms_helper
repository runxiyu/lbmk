#!/usr/bin/env sh

#  helper script: create ROM images for a given mainboard
#
#	Copyright (C) 2020,2021,2023 Leah Rowe <info@minifree.org>
#	Copyright (C) 2021,2022 Ferass El Hafidi
#				<vitali64pmemail@protonmail.com>
#	Copyright (C) 2022 Caleb La Grange <thonkpeasant@protonmail.com>
#	Copyright (C) 2022 Alper Nebi Yasak <alpernebiyasak@gmail.com>
#	Copyright (C) 2023 Riku Viitanen <riku.viitanen@protonmail.com>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# This script assumes that the working directory is the root
# of git or release archive


[ "x${DEBUG+set}" = 'xset' ] && set -v
set -u -e

. "include/err.sh"

projectname="$(cat projectname)"

blobs_required=""
microcode_required=""

board=""
ubdir=""
kmapdir="resources/grub/keymap"
displaymodes=""
payloads=""
keyboard_layouts=""
while [ $# -gt 0 ]; do
	case ${1} in
	-d)
		displaymodes="${displaymodes}${2}" 
		shift ;;
	-p)
		payloads="${payloads}${2}"
		shift ;;
	-k)
		keyboard_layouts="${keyboard_layouts}${2}"
		shift ;;
	*)
		board=${1} ;;
	esac
	shift
done

printf "\n\nboard is %s , kb is %s , displaymode is %s , payloads is %s\n" \
		${board} ${keyboard_layouts} ${displaymodes} ${payloads} 1>&2

[ ! -d "resources/coreboot/${board}" ] && \
	err "Target not defined: ${board}"

[ ! -f "resources/coreboot/${board}/target.cfg" ] && \
	err "Missing target.cfg for target: ${board}"

grub_scan_disk="undefined"
tree="undefined"
romtype="normal" # optional parameter in target.cfg. "normal" is default
arch="undefined"

# Disable all payloads by default.
# target.cfg files have to specifically enable [a] payload(s)
payload_grub="n"
payload_grub_withseabios="n" # seabios chainloaded from grub
payload_seabios="n"
payload_seabios_withgrub="n" # i386-coreboot grub from SeaBIOS boot menu
payload_memtest="n"
payload_uboot="n"
uboot_config="undefined"
# Override the above defaults using target.cfg
. "resources/coreboot/${board}/target.cfg"

[ "${grub_scan_disk}" = "undefined" ] && \
	grub_scan_disk="both"
[ "${grub_scan_disk}" != "both" ] && [ "${grub_scan_disk}" != "ata" ] && \
    [ "${grub_scan_disk}" != "ahci" ] && \
	grub_scan_disk="both"

[ "${tree}" = "undefined" ] && \
	err "Target '${board}' does not define a coreboot tree. Skipping build."
[ "${arch}" = "undefined" ] && \
	err "Target '${board}' does not define a CPU type. Skipping build."

[ "${payload_memtest}" != "y" ] && \
	payload_memtest="n"
[ "${payload_grub_withseabios}" = "y" ] && \
	payload_grub="y"
if [ "${payload_grub_withseabios}" = "y" ]; then
	payload_seabios="y"
	payload_seabios_withgrub="y"
fi
[ "${payload_seabios_withgrub}" = "y" ] && \
	payload_seabios="y"

# NOTE: reverse logic must NOT be applied. If SeaBIOS-with-GRUB works, that
# doesn't necessarily mean GRUb-with-SeaBIOS will. For example, the board
# might have an external GPU, where it's recommended to boot SeaBIOS first
if [ "${payload_grub}" != "y" ] && [ "${payload_seabios}" != "y" ] && \
    [ "${payload_uboot}" != "y" ]; then
	for configfile in "resources/coreboot/${board}/config/"*; do
		[ ! -e "${configfile}" ] && continue
		printf "ERROR build/roms: Target '%s' defines no payload. " \
				${board}
		printf "Exiting.\n"
		exit 1
	done
fi

[ "${payload_uboot}" != "n" ] && [ "${payload_uboot}" != "y" ] && \
	payload_uboot="n"
[ "${payload_uboot}" = "y" ] && [ "${uboot_config}" = "undefined" ] && \
	uboot_config="default"

[ "${microcode_required}" != "n" ] && [ "${microcode_required}" != "y" ] && \
	microcode_required="y"
[ "${blobs_required}" != "n" ] && [ "${blobs_required}" != "y" ] && \
	blobs_required="y"

# Override all payload directives with cmdline args
if [ ! -z ${payloads} ]; then	
	echo "setting payloads $payloads"
	payload_grub="n"
	payload_grub_withseabios="n" # seabios chainloaded from grub
	payload_seabios="n"
	payload_seabios_withgrub="n" # i386-coreboot grub from SeaBIOS menu
	payload_uboot="n"
	payload_memtest="n"

	for payload in ${payloads} ; do
		eval "payload_${payload}=y"
	done
fi 

romdir="bin/${board}"
cbdir="coreboot/${board}"
[ "${board}" = "${tree}" ] || \
	cbdir="coreboot/${tree}"
cbfstool="cbutils/${tree}/cbfstool"
corebootrom="${cbdir}/build/coreboot.rom"
seavgabiosrom="elf/seabios/default/libgfxinit/vgabios.bin"

./build coreboot utils ${tree} || exit 1

if [ ! -f "${seavgabiosrom}" ] \
    || [ ! -f elf/seabios/default/libgfxinit/bios.bin.elf ] \
    || [ ! -f elf/seabios/default/vgarom/bios.bin.elf ] \
    || [ ! -f elf/seabios/default/normal/bios.bin.elf ]; then
	[ "${payload_seabios}" = "y" ] && \
		./handle config file -b seabios
fi

memtest_bin="memtest86plus/build${arch#*_}/memtest.bin"
[ "${payload_memtest}" = "y" ] && [ ! -f "${memtest_bin}" ] && \
	./build src for -b ${memtest_bin%/*}

[ -d "${romdir}/" ] || mkdir -p "${romdir}/"
rm -f "${romdir}"/*

if [ "${payload_grub}" = "y" ] \
			|| [ "${payload_seabios_withgrub}" = "y" ]; then
	if [ -f "elf/grub/grub_usqwerty.cfg" ]; then
		sha1sumcmd="sha1sum resources/grub/config/grub.cfg"
		grubrefchecksum="$(${sha1sumcmd} | awk '{print $1}')"

		sha1sumcmd="sha1sum elf/grub/grub_usqwerty.cfg"
		grubbuildchecksum="$(${sha1sumcmd} | awk '{print $1}')"

		if [ "${grubrefchecksum}" != "${grubbuildchecksum}" ]; then
			printf "Changes detected to GRUB. Re-building now:\n"
		fi
	else
		printf "Required GRUB payloads not yet built. Building now:\n"
	fi
	for keymapfile in ${kmapdir}/*; do
		[ -f "${keymapfile}" ] || continue

		keymap="${keymapfile##*/}"
		keymap="${keymap%.gkb}"

		grubelf="elf/grub/grub_${keymap}.elf"
		grubcfg="elf/grub/grub_${keymap}.cfg"
		grubtestcfg="elf/grub/grub_${keymap}_test.cfg"

		if [ ! -f "${grubelf}" ] || [ ! -f "${grubcfg}" ] || \
		    [ ! -f "${grubtestcfg}" ]; then
			./build grub payload
		fi
	done
fi

if [ "${payload_uboot}" = "y" ]; then
	./handle config file -b u-boot ${board}
	ubdir="elf/u-boot/${board}/${uboot_config}"
	ubootelf="${ubdir}/u-boot.elf"
	[ ! -f "${ubootelf}" ] && [ -f "${ubdir}/u-boot.bin" ] && \
		ubootelf="${ubdir}/u-boot.bin"
	[ -f "${ubootelf}" ] || \
		err "Could not find u-boot build for board, ${board}"
fi

# it is assumed that no other work will be done on the ROM
# after calling this function. therefore this function is "final"
moverom() {
	rompath="$1"
	newrompath="$2"
	cuttype="$3"

	[ "${blobs_required}" = "n" ] && \
		newrompath="${newrompath%.rom}_noblobs.rom"

	printf "\nCreating new ROM image: %s\n" "${newrompath}"

	if [ "${cuttype}" = "4MiB IFD BIOS region" ]; then
		dd if=${rompath} of=${newrompath} bs=1 \
		    skip=$(($(stat -c %s ${rompath}) - 0x400000)) count=4194304
	else
		cp ${rompath} ${newrompath}
	fi

	# pike2008 cards cause a system hang when loading option roms in seabios
	# if there is an empty option rom in cbfs, no option rom will be loaded
	if [ "${cuttype}" = "d8d16sas" ]; then
		emptyrom=$(mktemp -t coreboot_rom.XXXXXXXXXX)
		rm -f "${emptyrom}"
		touch "${emptyrom}"
		for deviceID in "0072" "3050"; do
			"${cbfstool}" "${newrompath}" add -f "${emptyrom}" \
			    -n pci1000,${deviceID}.rom -t raw
		done
		rm -f "${emptyrom}"
	fi

	for romsize in 4 8 16; do
		ifdgbe="descriptors/ich9m/ich9fdgbe_${romsize}m.bin"
		if [ "${cuttype}" = "${romsize}MiB ICH9 IFD NOR flash" ]; then
			[ -f "${ifdgbe}" ] || \
				./build descriptors ich9m
			dd if=${ifdgbe} of=${newrompath} bs=1 count=12k \
			    conv=notrunc
		fi
		cmpstr="${romsize}MiB ICH9 IFD NOGBE NOR flash"
		ifdgbe="descriptors/ich9m/ich9fdnogbe_${romsize}m.bin"
		if [ "${cuttype}" = "${cmpstr}" ]; then
			[ -f "${ifdgbe}" ] || \
				./build descriptors ich9m
			dd if=${ifdgbe} of=${newrompath} bs=1 count=4k \
			    conv=notrunc
		fi
	done

	if [ "${cuttype}" = "i945 laptop" ]; then
		dd if=${newrompath} of=top64k.bin bs=1 \
		    skip=$(($(stat -c %s ${newrompath}) - 0x10000)) count=64k
		dd if=top64k.bin of=${newrompath} bs=1 \
		    seek=$(($(stat -c %s ${newrompath}) - 0x20000)) count=64k \
		    conv=notrunc
		rm -f top64k.bin
	fi

	if [ "${microcode_required}" = "n" ]; then
		_newrom_b="${newrompath%.rom}_nomicrocode.rom"
		cp "${newrompath}" "${_newrom_b}" || exit 1
		microcode_present="y"
		"${cbfstool}" "${_newrom_b}" remove -n \
		    cpu_microcode_blob.bin || microcode_present="n"
		if [ "${microcode_present}" = "n" ]; then
			rm -f "${_newrom_b}" || exit 1
			printf "REMARK: '%s' already lacks microcode\n" \
			    ${newrompath}
			printf "Renaming default ROM file instead.\n"
			mv "${newrompath}" "${_newrom_b}" || exit 1
		fi
	fi
}

# make a rom in /tmp/ and then print the path of that ROM
mkSeabiosRom() {
	target_cbrom="${1}" # rom to insert seabios in. will not be touched
		# (a tmpfile will be made instead)
	target_seabios_cbfs_path="${2}" # e.g. fallback/payload
	target_initmode="${3}" # e.g. libgfxinit

	target_seabioself="elf/seabios/default/${target_initmode}/bios.bin.elf"

	tmprom=$(mktemp -t coreboot_rom.XXXXXXXXXX)

	cp "${target_cbrom}" "${tmprom}"

	"${cbfstool}" "${tmprom}" add-payload -f "${target_seabioself}" \
	    -n ${target_seabios_cbfs_path} -c lzma || exit 1

	"${cbfstool}" "${tmprom}" add-int -i 3000 -n etc/ps2-keyboard-spinup \
	    || exit 1

	if [ "${target_initmode}" = "normal" ] || \
	    [ "${target_initmode}" = "libgfxinit" ]; then
		"${cbfstool}" "${tmprom}" add-int -i 2 \
		    -n etc/pci-optionrom-exec || exit 1
	elif [ "${target_initmode}" = "vgarom" ]; then # coreboot executes it
		"${cbfstool}" "${tmprom}" add-int -i 0 \
		    -n etc/pci-optionrom-exec || exit 1
	fi # for undefined modes, don't add this integer. use SeaBIOS defaults

	"${cbfstool}" "${tmprom}" add-int -i 0 -n etc/optionroms-checksum || \
	    exit 1

	[ "${target_initmode}" != "libgfxinit" ] || \
		"${cbfstool}" "${tmprom}" add -f "${seavgabiosrom}" \
		    -n vgaroms/seavgabios.bin -t raw || exit 1

	printf "%s\n" "${tmprom}"
}

# make a rom in /tmp/ and then print the path of that ROM
mkUbootRom() {
	target_cbrom="${1}" # rom to insert u-boot in. it won't be touched
		# (a tmpfile will be made instead)
	target_uboot_cbfs_path="${2}" # e.g. fallback/payload
	target_uboot_config="${3}"
	cbfstool_path="${4}"

	target_ubdir="elf/u-boot/${board}/${target_uboot_config}"
	target_ubootelf="${target_ubdir}/u-boot.elf"
	[ -f "${target_ubootelf}" ] || \
		target_ubootelf="${target_ubdir}/u-boot.bin"
	[ -f "${target_ubootelf}" ] || \
		err "Could not find u-boot build for board, ${board}"

	tmprom=$(mktemp -t coreboot_rom.XXXXXXXXXX)

	cp "${target_cbrom}" "${tmprom}"
	"${cbfstool}" "${tmprom}" add-payload -f "${target_ubootelf}" \
	    -n ${target_uboot_cbfs_path} -c lzma || exit 1

	printf "%s\n" "${tmprom}"
}

# make a rom in /tmp/ and then print the path of that ROM
mkGrubRom() {
	target_keymap="${1}"
	target_cbrom="${2}"
	target_grubelf_cbfs_path="${3}" # e.g. fallback/payload

	grubelf="elf/grub/grub_${target_keymap}.elf"
	grubcfg="elf/grub/grub_${target_keymap}.cfg"
	grubtestcfg="elf/grub/grub_${target_keymap}_test.cfg"

	tmprom=$(mktemp -t coreboot_rom.XXXXXXXXXX) || exit 1
	cp "${target_cbrom}" "${tmprom}" || exit 1

	"${cbfstool}" "${tmprom}" add-payload -f "${grubelf}" \
	    -n ${target_grubelf_cbfs_path} -c lzma || exit 1

	tmpgrubcfg=$(mktemp -t grub.cfg.XXXXXXXXXX)
	tmpgrubtestcfg=$(mktemp -t grubtest.cfg.XXXXXXXXXX)
	if [ "${grub_scan_disk}" = "ahci" ]; then
		sed \
		's/set\ grub_scan_disk=\"both\"/set\ grub_scan_disk=\"ahci\"/' \
		    "${grubcfg}" > "${tmpgrubcfg}"
		sed \
		's/set\ grub_scan_disk=\"both\"/set\ grub_scan_disk=\"ahci\"/' \
		    "${grubtestcfg}" > "${tmpgrubtestcfg}"
	elif [ "${grub_scan_disk}" = "ata" ]; then
		sed \
		's/set\ grub_scan_disk=\"both\"/set\ grub_scan_disk=\"ata\"/' \
		    "${grubcfg}" > "${tmpgrubcfg}"
		sed \
		's/set\ grub_scan_disk=\"both\"/set\ grub_scan_disk=\"ata\"/' \
		    "${grubtestcfg}" > "${tmpgrubtestcfg}"
	else
		cp "${grubcfg}" "${tmpgrubcfg}"
		cp "${grubtestcfg}" "${tmpgrubtestcfg}"
	fi

	"${cbfstool}" "${tmprom}" add -f "${tmpgrubcfg}" -n grub.cfg -t raw || \
	    exit 1

	"${cbfstool}" "${tmprom}" add -f "${tmpgrubtestcfg}" -n grubtest.cfg \
	    -t raw || exit 1
	rm -f "${tmpgrubcfg}" "${tmpgrubtestcfg}"

	backgroundfile="background1280x800.png"
	if [ "${board}" = "x60" ] || [ "${board}" = "t60_intelgpu" ]; then
		# TODO: don't hardcode this. do it in target.cfg per board
		backgroundfile="background1024x768.png"
	fi
	backgroundfile="resources/grub/background/${backgroundfile}"
	"${cbfstool}" "${tmprom}" add -f ${backgroundfile} -n background.png \
	    -t raw || exit 1

	printf "%s\n" "${tmprom}"
}

# Make separate ROM images with GRUB payload, for each supported keymap
mkRomsWithGrub() {
	tmprompath="${1}"
	initmode="${2}"
	displaymode="${3}"
	firstpayloadname="${4}" # allow values: grub, seabios, seabios_withgrub

	x=${tmprompath}
	y=${initmode}
	if [ "${payload_grub_withseabios}" = "y" ] && \
	    [ "${firstpayloadname}" = "grub" ]; then
		mv "$(mkSeabiosRom "${x}" "seabios.elf" "${y}")" "${tmprompath}"
	elif [ "${payload_seabios_withgrub}" ] && \
	    [ "${firstpayloadname}" != "grub" ]; then
		mv "$(mkSeabiosRom "${x}" "fallback/payload" "$y")" \
		    "${tmprompath}"
	fi	

	keymaps=""
	if [ -z ${keyboard_layouts} ]; then
		for kmapfile in "${kmapdir}"/*; do
			keymaps="${keymaps} ${kmapfile}"
		done
	else
		for keymapname in ${keyboard_layouts}; do
			keymaps="${keymaps} ${kmapdir}/${keymapname}.gkb"
		done
	fi
	for keymapfile in ${keymaps}; do
		echo "keymaps is $keymaps, keymapfile is $keymapfile"

		[ -f "${keymapfile}" ] || continue

		keymap="${keymapfile##*/}"
		keymap="${keymap%.gkb}"

		grub_path_in_cbfs="fallback/payload"
		[ "${firstpayloadname}" = "grub" ] || \
			grub_path_in_cbfs="img/grub2"

		# evil bofh rfc 2646 compliance hack
		x=${keymap}
		y=${tmprompath}
		z=${grub_path_in_cbfs}

		tmpgrubrom="$(mkGrubRom "${x}" "${y}" "${z}")"

		if [ "${initmode}" = "normal" ]; then
			newrompath="${romdir}/${firstpayloadname}_${board}_"
			newrompath="${newrompath}${initmode}_${keymap}.rom"
		else
			newrompath="${romdir}/${firstpayloadname}_${board}_"
			newrompath="${newrompath}${initmode}_${displaymode}_"
			newrompath="${newrompath}${keymap}.rom"
		fi
		moverom "${tmpgrubrom}" "${newrompath}" "${romtype}"
		rm -f "${tmpgrubrom}"
	done
}

# Main ROM building function. This calls all other functions
mkRoms()
{
	cbcfgpath="${1}"
	displaymode="${2}"
	initmode="${3}"

	if [ ! -f "${cbcfgpath}" ]; then
		printf "'%s' does not exist. Skipping build for %s %s %s\n" \
		    ${cbcfgpath} ${board} ${displaymode} ${initmode}
		return 0
	fi

	./handle config file -b coreboot ${board}

	_corebootrom="elf/coreboot/${board}/${initmode}_${displaymode}"
	[ "${initmode}" = "normal" ] && \
		_corebootrom="${_corebootrom%_${displaymode}}"
	_corebootrom="${_corebootrom}/coreboot.rom"
	corebootrom="$(mktemp -t coreboot_rom.XXXXXXXXXX)"
	cp "${_corebootrom}" "${corebootrom}"

	if [ "${payload_memtest}" = "y" ]; then
		"${cbfstool}" "${corebootrom}" add-payload \
				-f ${memtest_bin} -n img/memtest \
				-c lzma || exit 1
	fi

	if [ "${payload_seabios}" = "y" ]; then
		if [ "${payload_seabios_withgrub}" = "n" ]; then
			x=${corebootrom}
			y=${initmode}
			t=$(mkSeabiosRom "$x" "fallback/payload" "$y")
			if [ "${initmode}" = "normal" ]; then
				newrompath="${romdir}/seabios_${board}_"
				newrompath="${newrompath}${initmode}.rom"
			else
				newrompath="${romdir}/seabios_${board}_"
				newrompath="${newrompath}${initmode}_"
				newrompath="${newrompath}${displaymode}.rom"
			fi

			moverom "${t}" "${newrompath}" "${romtype}"
			rm -f "${t}"
		else
			tmprom=$(mktemp -t coreboot_rom.XXXXXXXXXX)
			cp "${corebootrom}" "${tmprom}"
			mkRomsWithGrub "${tmprom}" "${initmode}" \
			    "${displaymode}" "seabios_withgrub"
			rm -f "${tmprom}"
		fi
	fi

	[ "${payload_grub}" = "y" ] && \
		mkRomsWithGrub "${corebootrom}" "${initmode}" \
		    "${displaymode}" "grub"

	if [ "${payload_uboot}" = "y" ]; then
		x=${corebootrom}
		y=${uboot_config}
		z=${cbfstool}
		tmpubootrom="$(mkUbootRom "$x" "fallback/payload" "$y" "$z")"
		if [ "${initmode}" = "normal" ]; then
			newrompath="${romdir}/uboot_payload_${board}_"
			newrompath="${newrompath}${initmode}.rom"
		else
			newrompath="${romdir}/uboot_payload_${board}_"
			newrompath="${newrompath}${initmode}_${displaymode}.rom"
		fi
		moverom "${tmpubootrom}" "${newrompath}" "${romtype}"
		rm -f "${tmpubootrom}"
	fi
}

if [ -z ${displaymodes} ]; then
	initmode="libgfxinit"
	for displaymode in corebootfb txtmode; do
		cbcfgpath="resources/coreboot/${board}/config/${initmode}_"
		cbcfgpath="${cbcfgpath}${displaymode}"
		mkRoms "${cbcfgpath}" "${displaymode}" "${initmode}"
	done
	
	initmode="vgarom"
	for displaymode in vesafb txtmode; do	
		cbcfgpath="resources/coreboot/${board}/config/${initmode}_"
		cbcfgpath="${cbcfgpath}${displaymode}"
		mkRoms "${cbcfgpath}" "${displaymode}" "${initmode}"
	done
	
	initmode="normal"
	displaymode="txtmode"
	cbcfgpath="resources/coreboot/${board}/config/${initmode}"
	mkRoms "${cbcfgpath}" "${displaymode}" "${initmode}"

else
	echo "special displaymode defined as $displaymodes"
	initmode="libgfxinit"
	for displaymode in ${displaymodes}; do
		cbcfgpath="resources/coreboot/${board}/config/${initmode}_"
		cbcfgpath="${cbcfgpath}${displaymode}"
		mkRoms "${cbcfgpath}" "${displaymode}" "${initmode}"
	done

	initmode="vgarom"
	for displaymode in ${displaymodes}; do
		cbcfgpath="resources/coreboot/${board}/config/${initmode}_"
		cbcfgpath="${cbcfgpath}${displaymode}"
		mkRoms "${cbcfgpath}" "${displaymode}" "${initmode}"
	done
fi
