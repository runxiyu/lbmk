#!/usr/bin/env sh

# SPDX-FileCopyrightText: 2022 Caleb La Grange <thonkpeasant@protonmail.com>
# SPDX-FileCopyrightText: 2022 Ferass El Hafidi <vitali64pmemail@protonmail.com>
# SPDX-FileCopyrightText: 2023 Leah Rowe <info@minifree.org>
# SPDX-License-Identifier: GPL-3.0-only

agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"

ec_url=""
ec_url_bkup=""
ec_hash=""
dl_hash=""
dl_url=""
dl_url_bkup=""
dl_path=""
e6400_vga_dl_hash=""
e6400_vga_dl_url=""
e6400_vga_dl_url_bkup=""
e6400_vga_offset=""
e6400_vga_romname=""
sch5545ec_dl_url=""
sch5545ec_dl_url_bkup=""
sch5545ec_dl_hash=""

cbdir="coreboot/default"
cbcfgsdir="resources/coreboot"
boarddir=""
blobdir="blobs"
appdir="${blobdir}/app"
_7ztest="a"
mecleaner="$(pwd)/me_cleaner/me_cleaner.py"
e6400_unpack="$(pwd)/bios_extract/dell_inspiron_1100_unpacker.py"
me7updateparser="$(pwd)/resources/blobs/me7_update_parser.py"
kbc1126_ec_dump="$(pwd)/${cbdir}/util/kbc1126/kbc1126_ec_dump"
board=""
pfs_extract="$(pwd)/biosutilities/Dell_PFS_Extract.py"
uefiextract="$(pwd)/uefitool/uefiextract"
_b="" # board shorthand without e.g. _4mb (avoid duplication per flash size)

CONFIG_HAVE_MRC=""
CONFIG_HAVE_IFD_BIN=""
CONFIG_HAVE_ME_BIN=""
CONFIG_HAVE_GBE_BIN=""
CONFIG_KBC1126_FIRMWARE=""
CONFIG_BOARD_DELL_E6400=""
CONFIG_VGA_BIOS_FILE=""
CONFIG_INCLUDE_SMSC_SCH5545_EC_FW=""
CONFIG_SMSC_SCH5545_EC_FW_FILE=""

main()
{
	board="${1}"
	boarddir="${cbcfgsdir}/${board}"

	[ ! -d "${boarddir}" ] && \
		fail "Board target, ${board}, not defined"
	[ ! -f "${boarddir}/target.cfg" ] && \
		fail "Target missing target.cfg"

	no_config="printf \"No config for target, %s\\n\" ${board} 1>&2; exit 0"
	for x in "${boarddir}"/config/*; do
		[ -f "${x}" ] && no_config=""
	done
	eval "${no_config}"
	
	detect_firmware || exit 0
	scan_sources_config

	build_dependencies
	download_blobs
}

detect_firmware()
{
	set -- "${boarddir}/config/"*
	. ${1} 2>/dev/null
	. "${boarddir}/target.cfg"

	[ "${CONFIG_HAVE_MRC}" = "y" ] && needs="${needs} MRC"
	[ "${CONFIG_HAVE_IFD_BIN}" = "y" ] && needs="${needs} IFD"
	[ "${CONFIG_HAVE_ME_BIN}" = "y" ] && needs="${needs} ME"
	[ "${CONFIG_HAVE_GBE_BIN}" = "y" ] && needs="${needs} GBE"
	[ "${CONFIG_KBC1126_FIRMWARE}" = "y" ] && needs="${needs} EC"
	[ "${CONFIG_BOARD_DELL_E6400}" = "y" ] && \
	    [ "${CONFIG_VGA_BIOS_FILE}" != "" ] && needs="${needs} E6400VGA"
	[ "${CONFIG_INCLUDE_SMSC_SCH5545_EC_FW}" = "y" ] && \
	    needs="${needs} SCH5545EC"
	[ -z ${needs+x} ] && \
		printf 'No binary blobs needed for this board\n' && \
		return 1
	printf "Firmware needed for board '%s':\n%s\n" ${board} ${needs}
}

scan_sources_config()
{
	# Shorthand (avoid duplicating configs per flash size)
	_b=${board%%_*mb}

	awkstr=" /\{.*${_b}.*}{/ {flag=1;next} /\}/{flag=0} flag { print }"

	while read -r line ; do
		case ${line} in
		EC_url_bkup*)
			set ${line}
			ec_url_bkup=${2} ;;
		EC_url*)
			set ${line}
			ec_url=${2} ;;
		EC_hash*)
			set ${line}
			ec_hash=${2} ;;
		DL_hash*)
			set ${line}
			dl_hash=${2} ;;
		DL_url_bkup*)
			set ${line}
			dl_url_bkup=${2} ;;
		DL_url*)
			set ${line}
			dl_url=${2} ;;
		E6400_VGA_DL_hash*)
			set ${line}
			e6400_vga_dl_hash=${2} ;;
		E6400_VGA_DL_url_bkup*)
			set ${line}
			e6400_vga_dl_url_bkup=${2} ;;
		E6400_VGA_DL_url*)
			set ${line}
			e6400_vga_dl_url=${2} ;;
		E6400_VGA_offset*)
			set ${line}
			e6400_vga_offset=${2} ;;
		E6400_VGA_romname*)
			set ${line}
			e6400_vga_romname=${2} ;;
		SCH5545EC_DL_hash*)
			set ${line}
			sch5545ec_dl_hash=${2} ;;
		SCH5545EC_DL_url_bkup*)
			set ${line}
			sch5545ec_dl_url_bkup=${2} ;;
		SCH5545EC_DL_url*)
			set ${line}
			sch5545ec_dl_url=${2} ;;
		esac
	done << EOF
	$(eval "awk '${awkstr}' resources/blobs/sources")
EOF
}

build_dependencies()
{
	[ -d ${cbdir} ] || \
		./fetch_trees coreboot ${cbdir##*/} || \
		    fail "can't download to ${cbdir}"
	for d in uefitool biosutilities bios_extract me_cleaner; do
		[ -d "${d}" ] && continue
		./fetch ${d} || fail "can't download ${d}"
	done
	[ -f uefitool/uefiextract ] || \
		./build src for -b uefitool || fail "can't build uefitool"
	[ -f ${cbdir}/util/kbc1126/kbc1126_ec_dump ] || \
		make -BC ${cbdir}/util/kbc1126 || \
		    fail "can't build kbc1126_ec_dump"
}

download_blobs()
{
	for need in ${needs}; do
		case ${need} in
		*ME*)
			download_blob_intel_me || _failed="${_failed} me" ;;
		*SCH5545EC*)
			download_sch5545ec || failed="${_failed} sch5545ec" ;;
		*EC*)
			download_ec || _failed="${_failed} ec" ;;
		*E6400VGA*)
			download_e6400vga || _failed="${_failed} e6400vga" ;;
		*MRC*)
			./update blobs mrc || _failed="${_failed} mrc" ;;
		esac
	done
	
	[ -z ${_failed+x} ] || \
		fail "failed to obtain ${_failed}\nTry manual extraction?"
}

download_blob_intel_me()
{
	printf "Downloading neutered ME for board: %s\n" ${board}

	fetch_update me || return 1
	extract_blob_intel_me || return 1
}

extract_blob_intel_me()
{
	printf "Extracting neutered ME for ${board}\n"

	_me_destination=${CONFIG_ME_BIN_PATH#../../}

	[ -d "${_me_destination%/*}" ] || \
		mkdir -p ${_me_destination%/*}
	[ -d "${appdir}" ] && \
		rm -Rf ${appdir}
	if [ -f "${_me_destination}" ]; then
		printf 'me already downloaded\n'
		return 0
	fi

	printf "Extracting and stripping Intel ME firmware\n"

	innoextract ${dl_path} -d ${appdir} || \
	    7z x ${dl_path} -o${appdir} || \
	    unar "${dl_path}" -o "${appdir}" || \
	    fail "Could not extract vendor update"

	bruteforce_extract_blob_intel_me "$(pwd)/${_me_destination}" \
	    "$(pwd)/${appdir}" || fail "Could not extract Intel ME firmware"

	printf "Truncated and cleaned me output to ${_me_destination}\n"
}

# cursed, carcinogenic code. TODO rewrite it better
bruteforce_extract_blob_intel_me()
{
	_me_destination="${1}"
	cdir="${2}" # must be an absolute path, not relative

	[ -f "${_me_destination}" ] && return 0

	sdir="$(mktemp -d)"
	mkdir -p "${sdir}" || return 1

	(
	printf "Entering %s\n" "${cdir}"
	cd "${cdir}" || exit 1
	for i in *; do
		if [ -f "${_me_destination}" ]; then
			# me.bin found, so avoid needless further traversal
			break
		elif [ -L "${i}" ]; then
			# symlinks are a security risk, in this context
			continue
		elif [ -f "${i}" ]; then
			"${mecleaner}" -r -t -O "${sdir}/vendorfile" \
					-M "${_me_destination}" "${i}" \
				&& break # (we found me.bin)	
			"${mecleaner}" -r -t -O "${_me_destination}" "${i}" \
				&& break # (we found me.bin)
			"${me7updateparser}" -O ${_me_destination} "${i}" \
				&& break # (we found me.bin)
			_7ztest="${_7ztest}a"
			7z x "${i}" -o${_7ztest} \
			    || innoextract "${i}" -d  "${_7ztest}" \
			    || unar "${i}" -o "${_7ztest}" \
			    || continue
			bruteforce_extract_blob_intel_me "${_me_destination}" \
					"${cdir}/${_7ztest}"
		elif [ -d "$i" ]; then
			bruteforce_extract_blob_intel_me "${_me_destination}" \
					"${cdir}/${i}"
		else
			printf "SKIPPING: %s\n" "${i}"
			continue
		fi
		cdir="${1}"
		cd "${cdir}"
	done
	)

	rm -Rf "${sdir}"

	if [ ! -f "${_me_destination}" ]; then
		printf "me.bin not found in vendor update for: %s\n" ${board}
		return 1
	fi
}

download_ec()
{
	printf "Downloading KBC1126 EC firmware for HP laptop\n"

	fetch_update ec || return 1
	extract_blob_kbc1126_ec || return 1
}

extract_blob_kbc1126_ec()
{
	printf "Extracting KBC1126 EC firmware for board: %s\n" ${board}

	_ec_destination=${CONFIG_KBC1126_FW1#../../}

	[ -d "${_ec_destination%/*}" ] || \
		mkdir -p "${_ec_destination%/*}"
	[ -d "${appdir}" ] && \
		rm -Rf "${appdir}"
	if [ -f "${_ec_destination}" ]; then
		printf "ec already downloaded\n"
		return 0
	fi

	unar "${dl_path}" -o "${appdir}"

	(
	cd "${appdir}/${dl_path##*/}"

	mv Rompaq/68*.BIN ec.bin
	if [ ! -f ec.bin ]; then
		unar -D ROM.CAB Rom.bin || \
		    unar -D Rom.CAB Rom.bin || \
		    unar -D 68*.CAB Rom.bin
		mv Rom.bin ec.bin
	fi

	[ -f ec.bin ] || fail "could not extract ec.bin for board, ${board}"
	"${kbc1126_ec_dump}" ec.bin
	)

	for i in 1 2; do
		[ -f "${appdir}/${dl_path##*/}/ec.bin.fw${i}" ] && continue
		printf "Could not extract EC firmware for: %s\n" \
		    ${board}
		return 1
	done

	cp "${appdir}/${dl_path##*/}"/ec.bin.fw* "${_ec_destination%/*}/"
}

download_e6400vga()
{
	printf "Downloading Nvidia VGA ROM for Dell Latitude E6400\n"

	fetch_update e6400vga || return 1
	extract_e6400vga || return 1
}

extract_e6400vga()
{
	printf "Extracting Nvidia VGA ROM for ${board}\n"

	_vga_destination=${CONFIG_VGA_BIOS_FILE#../../}

	if [ -f "${_vga_destination}" ]; then
		printf 'vga rom already downloaded\n'
		return 0
	fi
	[ -d "${_vga_destination%/*}" ] || \
		mkdir -p ${_vga_destination%/*}
	[ -d "${appdir}" ] && \
		rm -Rf ${appdir}

	mkdir -p "${appdir}"
	mv "${dl_path}" "${appdir}"

	if [ "${e6400_vga_offset}" = "" ]; then
		printf "E6400 VGA offset not defined\n"
		return 1
	elif [ "${e6400_vga_romname}" = "" ]; then
		printf "E6400 VGA ROM name not defined\n"
		return 1
	fi

	(
	cd "${appdir}"
	tail -c +${e6400_vga_offset} "${dl_path##*/}" \
			| gunzip > bios.bin
	[ -f "bios.bin" ] || \
		fail "Could not extract bios.bin from Dell E6400 update"
	"${e6400_unpack}" bios.bin || printf "TODO: fix dell extract util\n"
	[ -f "${e6400_vga_romname}" ] || \
		fail "Could not extract VGA ROM from Dell E6400 BIOS update"
	)

	cp "${appdir}"/"${e6400_vga_romname}" "${_vga_destination}"

	printf "E6400 Nvidia ROM saved to: %s\n" "${_vga_destination}"
}

download_sch5545ec()
{
	printf "Downloading SMSC SCH5545 Environment Controller firmware\n"

	fetch_update sch5545ec || return 1
	extract_sch5545ec || return 1
}

# TODO: this code is cancer. hardcoded is bad, and stupid.
# TODO: make it *scan* (based on signature, in each file)
extract_sch5545ec()
{
	printf "Extracting SCH5545 Environment Controller firmware for '%s'\n" \
	    ${board}

	_sch5545ec_destination=${CONFIG_SMSC_SCH5545_EC_FW_FILE#../../}

	if [ -f "${_sch5545ec_destination}" ]; then
		printf 'sch5545 firmware already downloaded\n'
		return 0
	fi

	[ -d "${appdir}" ] rm -Rf "${appdir}"

	mkdir -p "${appdir}/"
	cp "${dl_path}" "${appdir}/"
	python "${pfs_extract}" "${appdir}/${dlsum}" -e || exit 1

	# full system ROM (UEFI), to extract with UEFIExtract:
	_bios="${appdir}/${dlsum}_extracted/Firmware"
	_bios="${_bios}/1 ${dlsum} -- 1 System BIOS vA.28.bin"

	# this is the SCH5545 firmware, inside of the extracted UEFI ROM:
	_sch5545ec_fw="${_bios}.dump/4 7A9354D9-0468-444A-81CE-0BF617D890DF"
	_sch5545ec_fw="${_sch5545ec_fw}/54 D386BEB8-4B54-4E69-94F5-06091F67E0D3"
	_sch5545ec_fw="${_sch5545ec_fw}/0 Raw section/body.bin" # <-- this!

	# this makes the file defined by _sch5545ec_fw available to copy
	"${uefiextract}" "${_bios}" || exit 1

	cp "${_sch5545ec_fw}" "${_sch5545ec_destination}" || exit 1
}

fetch_update()
{
	printf "Fetching vendor update for board: %s\n" ${board}

	fw_type="${1}"
	dl=""
	dl_bkup=""
	dlsum=""
	if [ "${fw_type}" = "me" ]; then
		dl=${dl_url}
		dl_bkup=${dl_url_bkup}
		dlsum=${dl_hash}
	elif [ "${fw_type}" = "ec" ]; then
		dl=${ec_url}
		dl_bkup=${ec_url_bkup}
		dlsum=${ec_hash}
	elif [ "${fw_type}" = "e6400vga" ]; then
		dl=${e6400_vga_dl_url}
		dl_bkup=${e6400_vga_dl_url_bkup}
		dlsum=${e6400_vga_dl_hash}
	elif [ "${fw_type}" = "sch5545ec" ]; then
		dl="${sch5545ec_dl_url}"
		dl_bkup="${sch5545ec_dl_url_bkup}"
		dlsum="${sch5545ec_dl_hash}"
	else
		printf "Unsupported download type: %s\n" ${fw_type}
		return 1
	fi

	if [ -z "${dl_url+x}" ] && [ "${fw_type}" != "e6400vga" ]; then
		printf "No vendor update specified for board: %s\n" ${board}
		return 1
	fi

	dl_path=${blobdir}/cache/${dlsum}
	mkdir -p ${blobdir}/cache

	dl_fail="y"
	vendor_checksum ${dlsum} && dl_fail="n"
	for x in "${dl}" "${dl_bkup}"; do
		[ "${dl_fail}" = "n" ] && break
		rm -f "${dl_path}"
		wget -U "${agent}" ${x} -O ${dl_path}
		vendor_checksum ${dlsum} && dl_fail="n"
	done
	if [ "${dl_fail}" = "y" ]; then
		printf "Could not download blob file\n" 1>&2
		return 1
	fi
}

vendor_checksum()
{
	if [ ! -f "${dl_path}" ]; then
		printf "Vendor update not found on disk for: %s\n" ${board}
		return 1
	elif [ "$(sha1sum ${dl_path} | awk '{print $1}')" != "${1}" ]; then
		printf "Bad checksum on vendor update for: %s\n" ${board}
		return 1
	fi
}

fail()
{
	printf "\nERROR: $@\n"
	exit 1
}

main $@
