#!/usr/bin/env sh

#  helper script: build elf files on build systems that use defconfig/kconfig
#
#	Copyright (C) 2022 Alper Nebi Yasak <alpernebiyasak@gmail.com>
#	Copyright (C) 2022 Ferass El Hafidi <vitali64pmemail@protonmail.com>
#	Copyright (C) 2023 Leah Rowe <leah@libreboot.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

# you could probably build *linux* with this script!

[ "x${DEBUG+set}" = 'xset' ] && set -v
set -u -e

projectname="$(cat projectname)"
our_version="$(cat version)"

export LOCALVERSION="-${projectname}-${our_version}"

arch=""
cfgsdir=""
codedir=""
config=""
config_name=""
crossgcc_ada=""
elfdir=""
listfile=""
project=""
target=""
target_dir=""
tree=""

main()
{
	[ $# -lt 1 ] && err "Project name not specified"
	project="${1}"
	elfdir="elf/${project}"
	shift 1

	cfgsdir="resources/${project}"
	[ -d "${cfgsdir}" ] || err "directory, ${cfgsdir}, does not exist"

	listfile="${cfgsdir}/build.list"
	[ -f "${listfile}" ] || err "list file, ${listfile}, does not exist"

	printf "Building %s binaries (elf files)\n" ${project}

	# Build for all targets if no argument is given
	if [ "$#" -eq 0 ]; then
		for target_dir in "${cfgsdir}"/*; do
			[ ! -d "${target_dir}/config/" ] && \
				continue
			set -- "$@" "${target_dir#${cfgsdir}/}"
		done
	fi

	[ ! -d "${elfdir}" ] && \
		mkdir -p ${elfdir}/

	for x in "$@"; do
		target="${x}"
		if [ "${project}" = "coreboot" ]; then
			./update blobs download ${target} || err "blobutil"
		fi
		build_defconfig || exit 1
	done

	printf "Done! The files are stored under %s/\n\n" ${elfdir}
}

build_defconfig()
{
	handle_dependencies "${target}" || return 1

	for y in "${target_dir}/config"/*; do
		[ ! -f "${y}" ] && continue
		config="${y}"
		config_name="${config#$target_dir/config/}"

		printf "build/defconfig/%s %s: build config %s\n" \
		    ${project} ${target} ${config_name}

		check_config || continue
		build_elf
		copy_elf
	done
}

handle_dependencies()
{
	target_dir="${cfgsdir}/${target}"
	mkdir -p "${elfdir}/${target}"

	tree="undefined"
	arch="undefined"

	[ ! -f "${target_dir}/target.cfg" ] && \
		err "build/${project} ${target}: Missing target.cfg"

	# Override the above defaults using target.cfg
	. "${target_dir}/target.cfg" # source

	[ "${tree}" = "undefined" ] && \
		err "build/${project} %{target}: tree undefined"
	[ "${arch}" = "undefined" ] && \
		err "build/${project} ${target}: undefined cpu type"

	codedir="${project}/${tree}"
	[ -d "${codedir}" ] || \
		./fetch_trees "${project}" "$target" || exit 1

	# u-boot and coreboot are both compiled with coreboot's crossgcc
	if [ "${project}" = "coreboot" ] || [ "${project}" = "u-boot" ]; then
		check_cross_compiler || err "crossgcc fail"
	fi
}

# set up cross-compiler (coreboot crossgcc) for u-boot and coreboot
# (seabios and grub currently use hostcc, not crossgcc)
check_cross_compiler()
{
	[ "${crossgcc_ada}" = "y" ] || [ "${crossgcc_ada}" = "n" ] || \
		crossgcc_ada="y"
	[ "${crossgcc_ada}" != "y" ] && \
		export BUILD_LANGUAGES=c

	cbdir="coreboot/${tree}"
	[ "${project}" != "coreboot" ] && \
		cbdir="coreboot/default" # not u-boot (e.g. linux will use it)
	[ "${project}" = "u-boot" ] && \
		cbdir="coreboot/cros" # u-boot only used on coreboot/cros
	# only true if not building coreboot:
	[ -d "${cbdir}" ] || \
		./fetch_trees coreboot ${cbdir#coreboot/} || \
		    err "check_cross_compiler"

	if [ "${arch}" = "x86_32" ] || [ "${arch}" = "x86_64" ]; then
		if [ ! -d "${cbdir}/util/crossgcc/xgcc/i386-elf/" ]; then
			# Even for 64-bit machines, coreboot builds 32-bit ROM
			# images, so we only need to worry about i386-elf
			make -C "${cbdir}" crossgcc-i386 CPUS=$(nproc) || \
			    return 1
		fi
		case "$(uname -m)" in
			x86*|i*86|amd64) : ;;
			*) export CROSS_COMPILE=i386-elf- ;;
		esac
	elif [ "${arch}" = "ARMv7" ]; then
		if [ ! -d "${cbdir}/util/crossgcc/xgcc/arm-eabi/" ]; then
			make -C "${cbdir}" crossgcc-arm CPUS=$(nproc) || \
			    return 1
		fi
		case "$(uname -m)" in
			arm|arm32|armv6*|armv7*) : ;;
			*) export CROSS_COMPILE=arm-eabi- ;;
		esac
	elif [ "${arch}" = "AArch64" ]; then
		if [ ! -d "${cbdir}/util/crossgcc/xgcc/aarch64-elf/" ]; then
			make -C "${cbdir}" crossgcc-aarch64 CPUS=$(nproc) || \
			    return 1
		fi
		# aarch64 also needs armv7 toolchain for arm-trusted-firmware
		if [ ! -d "${cbdir}/util/crossgcc/xgcc/arm-eabi/" ]; then
			make -C "${cbdir}" crossgcc-arm CPUS=$(nproc) || \
			    return 1
		fi
		case "$(uname -m)" in
			arm64|aarch64) : ;;
			*) export CROSS_COMPILE=aarch64-elf- ;;
		esac
	fi

	# we *must* ensure that u-boot's build system uses crossgcc first
	export PATH="$(pwd)/${cbdir}/util/crossgcc/xgcc/bin:$PATH"
}

check_config()
{
	[ ! -f "${config}" ] && \
		err "build/${project} ${target}: configs missing"

	dest_dir="${elfdir}/${target}/${config_name}"
	for elftest in "${dest_dir}"/*; do
		if [ -f "${elftest}" ]; then
			printf "Build already exists, so skipping build\n" 1>&2
			return 1
		fi
	done
	mkdir -p "${dest_dir}"

	printf "build/%s %s: building config %s).\n" \
			${project} ${target} ${config_name}
}

build_elf()
{
	make -C "${codedir}" distclean || err "build_elf"

	cp "${config}" "${codedir}/.config" || err "build_elf"
	make -C "${codedir}" silentoldconfig || \
	    make -C "${codedir}" oldconfig || : # don't error on oldconfig

	[ "${project}" = "coreboot" ] && \
		printf "%s\n" "${our_version}" > "${codedir}/.coreboot-version"
	make -C "${codedir}" -j"$(nproc)" all || err "build_elf"
}

copy_elf()
{
	for f in $(cat "${listfile}"); do
		[ -f "${codedir}/$f" ] && cp "${codedir}/${f}" "${dest_dir}/"
	done

	make -C "${codedir}" distclean || \
	    make -C "${codedir}" clean || err "copy_elf"
}

err()
{
	[ -z "${codedir}" ] || \
		make -C "${codedir}" distclean \
		    || make -C "${codedir}" clean || :

	printf "build/defconfig error %s\n" "${1}" 1>&2
	exit 1
}

main $@
