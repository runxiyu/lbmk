#!/usr/bin/env sh
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2014,2015,2020-2024 Leah Rowe <leah@libreboot.org>
# SPDX-FileCopyrightText: 2015 Patrick "P. J." McDermott <pj@pehjota.net>
# SPDX-FileCopyrightText: 2015, 2016 Klemens Nanni <contact@autoboot.org>
# SPDX-FileCopyrightText: 2022, Caleb La Grange <thonkpeasant@protonmail.com>

set -u -e

if [ "./${0##*/}" != "${0}" ] || [ ! -f "build" ] || [ -L "build" ]; then
	printf "You must run this in the proper work directory.\n" 1>&2
	exit 1
fi

. "include/option.sh"
. "include/vendor.sh"
. "include/mrc.sh"

eval "$(setvars "" aur_notice vdir src_dirname srcdir _xm mode xp)"
err="fail"

linkpath="${0}"
linkname="${linkpath##*/}"

main()
{
	x_ id -u 1>/dev/null 2>/dev/null
	[ $# -lt 1 ] && $err "Check $projectname documentation for help."
	spath="script/$1"

	[ "$1" = "dependencies" ] && x_ install_packages $@ && xbmk_exit 0

	which git 1>/dev/null 2>/dev/null || \
	    git_err "git not installed. please install git-scm."
	git config --global user.name 1>/dev/null 2>/dev/null || \
	    git_err "git config --global user.name \"John Doe\""
	git config --global user.email 1>/dev/null 2>/dev/null || \
	    git_err "git config --global user.email \"john.doe@example.com\""

	initcmd $@
	git_init

	[ -f "${spath}" ] || $err "Bad command. Check $projectname docs."
	shift 1; "$spath" $@ || $err "excmd: ${spath} ${@}"

	xbmk_exit 0
}

initcmd()
{
	[ "$(id -u)" != "0" ] || $err "this command as root is not permitted"

	case "${1}" in
	version) printf "%s\n" "$relname" ;;
	release) shift 1; mkrelease $@ ;;
	inject) shift 1; vendor_inject $@ ;;
	download) shift 1; vendor_download $@ ;;
	*) return 0 ;;
	esac
	set -u -e # some commands disable them. turn them on!
	xbmk_exit 0
}

install_packages()
{
	if [ $# -lt 2 ]; then
		printf "You must specify a distro, namely:\n" 1>&2
		printf "Look at files under config/dependencies/\n" 1>&2
		printf "Example: ./build dependencies debian\n" 1>&2
		$err "install_packages: target not specified"
	fi

	[ -f "config/dependencies/${2}" ] || $err "Unsupported target"

	. "config/dependencies/${2}"

	x_ ${pkg_add} ${pkglist}
	[ -z "${aur_notice}" ] && return 0
	printf "You must install AUR packages: %s\n" "$aur_notice" 1>&2
}

# release archives contain .gitignore, but not .git.
# xbmk can be run from xbmk.git, or an archive.
git_init()
{
	[ -L ".git" ] && $err "Reference .git is a symlink"
	[ -e ".git" ] && return 0
	eval "$(setvars "$(date -Rud @${versiondate})" cdate _nogit)"

	git init || $err "${PWD}: cannot initialise Git repository"
	git add -A . || $err "${PWD}: cannot add files to Git repository"
	git commit -m "${projectname} ${version}" --date "${cdate}" \
	    --author="xbmk <xbmk@example.com>" || \
	    $err "$PWD: can't commit ${projectname}/${version}, date $cdate"
	git tag -a "${version}" -m "${projectname} ${version}" || \
	    $err "${PWD}: cannot git-tag ${projectname}/${version}"
}

mkrelease()
{
	export XBMK_RELEASE="y"

	vdir="release"
	while getopts d:m: option; do
		[ -z "${OPTARG}" ] && $err "Empty argument not allowed"
		case "${option}" in
		d) vdir="${OPTARG}" ;;
		m) mode="${OPTARG}" ;;
		*) $err "Invalid option" ;;
		esac
	done

	vdir="${vdir}/${version}"
	src_dirname="${relname}_src"
	srcdir="${vdir}/${src_dirname}"

	[ -e "${vdir}" ] && $err "already exists: \"${vdir}\""
	mkdir -p "${vdir}" || $err "mkvdir: !mkdir -p \"${vdir}\""
	git clone . "${srcdir}" || $err "mkdir: !gitclone \"${srcdir}\""

	build_release

	printf "\n\nDONE! Check release files under %s\n" "${vdir}"
}

build_release()
{
	_xm="build_release ${vdir}"
	(
	cd "${srcdir}" || $err "${_xm}: !cd \"${srcdir}\""
	fetch_trees
	x_ mv src/docs docs
	) || $err "can't create release files"

	git log --graph --pretty=format:'%Cred%h%Creset %s %Creset' \
	    --abbrev-commit > "${srcdir}/CHANGELOG" || \
	    $err "build_release $srcdir: couldn't generate changelog"

	(
	cd "${srcdir%/*}" || $err "${_xm}: mktarball \"${srcdir}\""
	mktarball "${srcdir##*/}" "${srcdir##*/}.tar.xz" || \
	    $err "$_xm: mksrc"
	) || $err "can't create src tarball"
	[ "${mode}" = "src" ] && return 0

	(
	cd "${srcdir}" || $err "${_xm}: 2 !cd \"${srcdir}\""
	./build roms all || $err "${_xm}: roms-all"
	./build roms serprog rp2040 || $err "${_xm}: rp2040"
	./build roms serprog stm32 || $err "${_xm}: stm32"
	x_ mv bin ../roms
	) || $err "can't build rom images"

	rm -Rf "${srcdir}" || $err "!rm -Rf ${srcdir}"
}

fetch_trees()
{
	for x in $(items config/git); do
		./update trees -f "$x" || $err "$_xm: fetch $x"
	done

	for x in config/*/build.list; do
		[ -f "$x" ] && xp="${x#*/}" && xp="${xp%/*}"
		[ ! -f "$x" ] || [ -L "$xp" ] || x_ rm -Rf "src/$xp/$xp"
	done

	find . -name ".git" -exec rm -Rf {} + || $err "$_xm: rm .git"
	find . -name ".gitmodules" -exec rm -Rf {} + || $err "$_xm: rm .gitmod"
	rm -Rf tmp .git src/u-boot/*/test/lib/strlcat.c || $err "$_xm !rm"
}

xbmk_exit()
{
	tmp_cleanup || err_ "xbmk_exit: can't rm tmpdir upon exit $1: $tmpdir"
	exit $1
}

fail()
{
	tmp_cleanup || printf "WARNING: can't rm tmpdir: %s\n" "$tmpdir" 1>&2
	err_ "${1}"
}

tmp_cleanup()
{
	[ "${tmpdir_was_set}" = "n" ] || return 0
	rm -Rf "${tmpdir}" || return 1
}

main $@
