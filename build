#!/usr/bin/env sh
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2014,2015,2020-2024 Leah Rowe <leah@libreboot.org>
# SPDX-FileCopyrightText: 2015 Patrick "P. J." McDermott <pj@pehjota.net>
# SPDX-FileCopyrightText: 2015, 2016 Klemens Nanni <contact@autoboot.org>
# SPDX-FileCopyrightText: 2022, Caleb La Grange <thonkpeasant@protonmail.com>

set -u -e

if [ "./${0##*/}" != "${0}" ] || [ ! -f "build" ] || [ -L "build" ]; then
	printf "You must run this in the lbmk work directory.\n" 1>&2
	exit 1
fi

. "include/option.sh"
. "include/vendor.sh"
. "include/mrc.sh"

eval "$(setvars "" script_path aur_notice vdir relname src_dirname srcdir \
    _xm target romdir mode)"
err="fail"

linkpath="${0}"
linkname="${linkpath##*/}"

main()
{
	x_ id -u 1>/dev/null 2>/dev/null
	[ $# -lt 1 ] && $err "Too few arguments. Try: ${0} help"

	[ "$1" = "dependencies" ] && x_ install_packages $@ && lbmk_exit 0

	for cmd in initcmd check_git check_project git_init excmd; do
		eval "${cmd} \$@"
	done
	lbmk_exit 0
}

initcmd()
{
	[ "$(id -u)" != "0" ] || $err "this command as root is not permitted"

	check_project

	case "${1}" in
	help) usage ${0} ;;
	list) items "script" ;;
	version) mkversion ;;
	release) shift 1; mkrelease $@ ;;
	inject) shift 1; vendor_inject $@ ;;
	download) shift 1; vendor_download $@ ;;
	*)
		script_path="script/${1}"
		return 0 ;;
	esac
	set -u -e # some commands disable them. turn them on!
	lbmk_exit 0
}

install_packages()
{
	if [ $# -lt 2 ]; then
		printf "You must specify a distro, namely:\n" 1>&2
		printf "Look at files under config/dependencies/\n" 1>&2
		printf "Example: ./build dependencies debian\n" 1>&2
		$err "install_packages: target not specified"
	fi

	[ -f "config/dependencies/${2}" ] || $err "Unsupported target"

	. "config/dependencies/${2}"

	x_ ${pkg_add} ${pkglist}
	[ -z "${aur_notice}" ] && return 0
	printf "You must install AUR packages: %s\n" "$aur_notice" 1>&2
}

# release archives contain .gitignore, but not .git.
# lbmk can be run from lbmk.git, or an archive.
git_init()
{
	[ -L ".git" ] && $err "Reference .git is a symlink"
	[ -e ".git" ] && return 0
	eval "$(setvars "$(date -Rd @${versiondate})" cdate _nogit)"

	git init || $err "${PWD}: cannot initialise Git repository"
	git add -A . || $err "${PWD}: cannot add files to Git repository"
	git commit -m "${projectname} ${version}" --date "${cdate}" \
	    --author="lbmk <lbmk@libreboot.org>" || \
	    $err "$PWD: can't commit ${projectname}/${version}, date $cdate"
	git tag -a "${version}" -m "${projectname} ${version}" || \
	    $err "${PWD}: cannot git-tag ${projectname}/${version}"
}

excmd()
{
	[ -f "${script_path}" ] || $err "Bad command. Run: ${linkpath} help"
	shift 1; "$script_path" $@ || $err "excmd: ${script_path} ${@}"
}

usage()
{
	progname=${0}
	cat <<- EOF
	$(mkversion)

	USAGE:	${progname} <OPTION>

	possible values for 'OPTION':
	$(items "script")

	Special commands (consult $projectname documentation):
	./vendor inject
	./vendor download
	./update release
	./build dependencies distroname
	(replace distroname with a filename from config/dependencies/)

	To know what ${projectname} version you're on, type:
	${progname} version

	Refer to ${projectname} documentation for more info.
	EOF
}

mkrelease()
{
	export LBMK_RELEASE="y"
	export LBMK_STATUS="n"

	vdir="release"
	while getopts d:m: option; do
		[ -z "${OPTARG}" ] && $err "Empty argument not allowed"
		case "${option}" in
		d) vdir="${OPTARG}" ;;
		m) mode="${OPTARG}" ;;
		*) $err "Invalid option" ;;
		esac
	done

	check_project

	vdir="${vdir}/${version}"
	relname="${projectname}-${version}"
	[ "${mode}" = "u-boot" ] && relname="u-boot-for-${relname}"
	src_dirname="${relname}_src"
	srcdir="${vdir}/${src_dirname}"

	[ -e "${vdir}" ] && $err "already exists: \"${vdir}\""

	mkvdir
	build_release

	printf "DONE! Check release files under %s\n" "${vdir}"
}

mkvdir()
{
	mkdir -p "${vdir}" || $err "mkvdir: !mkdir -p \"${vdir}\""
	git clone . "${srcdir}" || $err "mkdir: !gitclone \"${srcdir}\""
	insert_version_files "$srcdir" || $err "mkvdir $srcdir: versionfile"
}

build_release()
{
	_xm="build_release ${vdir}"
	(
	cd "${srcdir}" || $err "${_xm}: !cd \"${srcdir}\""
	fetch_trees
	[ "${mode}" = "u-boot" ] || x_ mv src/docs docs
	) || $err "can't create release files"

	git log --graph --pretty=format:'%Cred%h%Creset %s %Creset' \
	    --abbrev-commit > "${srcdir}/CHANGELOG" || \
	    $err "build_release $srcdir: couldn't generate changelog"

	(
	if [ "${mode}" = "u-boot" ]; then
		cd "${srcdir}/src/" || $err "${_xm}: mktarball \"${srcdir}\""
		mktarball u-boot "../../${srcdir##*/}.tar.xz" || \
		    $err "$_xm: mksrc"
		# make a src archive containing only u-boot
	else
		cd "${srcdir%/*}" || $err "${_xm}: mktarball \"${srcdir}\""
		mktarball "${srcdir##*/}" "${srcdir##*/}.tar.xz" || \
		    $err "$_xm: mksrc"
	fi
	) || $err "can't create src tarball"
	[ "${mode}" = "src" ] && return 0
	[ "${mode}" = "u-boot" ] && return 0

	(
	cd "${srcdir}" || $err "${_xm}: 2 !cd \"${srcdir}\""
	mkrom_images
	) || $err "can't build rom images"

	rm -Rf "${srcdir}" || $err "!rm -Rf ${srcdir}"
}

fetch_trees()
{
	for x in config/git/*; do
		[ "${mode}" = "u-boot" ] && break
		[ ! -f "${x}" ] || ./update trees -f "${x#config/git/}" || \
		    $err "${_xm}: fetch ${x#config/git/}"
	done
	[ "${mode}" = "u-boot" ] && x_ ./update trees -f u-boot

	for x in config/*/build.list; do
		[ -f "${x}" ] || continue
		xp="${x#*/}"; xp="${xp%/*}"
		[ -L "${xp}" ] || rm -Rf "src/${xp}/${xp}" || \
		    $err "!rm -Rf \"src/${xp}/${xp}\""
	done

	find . -name ".git" -exec rm -Rf {} + || $err "$_xm: rm .git"
	find . -name ".gitmodules" -exec rm -Rf {} + || $err "$_xm: rm .gitmod"
	x_ rm -Rf tmp .git
}

mkrom_images()
{
	./build roms all || $err "${_xm}: roms-all"
	./build roms serprog rp2040 || $err "${_xm}: rp2040"
	./build roms serprog stm32 || $err "${_xm}: stm32"

	for rombuild in bin/*; do
		[ -d "${rombuild}" ] || continue
		handle_rom_archive "${rombuild}"
	done

	mv "release/${version}/roms/" ../roms || $err "${_xm}: copy roms/"
}

handle_rom_archive()
{
	builddir="${1}"
	romdir="tmp/romdir"
	rm -Rf "${romdir}" || $err "!rm romdir, handle_rom_archive"
	target="${builddir##*/}"

	if [ ! -f "config/coreboot/${target}/target.cfg" ]; then
		# No config, just make a tarball
		tarball="release/${version}/roms/${relname}_${target}.tar.xz"
		insert_copying_files "${builddir}" || \
		    $err "!insert copy, handle, ${builddir}"
		mktarball "${builddir}" "${tarball}"
		return 0
	fi

	romdir="${romdir}/bin/${target}"
	mkdir -p "${romdir}" || $err "!mkdir -p romdir, handle_rom_archive"
	cp "$builddir/"* "$romdir" || $err "!cp romdir, handle_rom_archive"

	nukerom

	printf "Generating release/%s/roms/%s-%s_%s.tar.xz\n" \
	    "${version}" "${projectname}" "${version}" "${target##*/}"
	insert_version_files "${romdir}" || \
	    $err "mkrom_tarball ${romdir}: versionfile"

	insert_copying_files "$romdir" || $err "!insert copy, handle 2, $romdir"
	mkrom_tarball
}

nukerom()
{
	. "config/coreboot/${target}/target.cfg"

	# Hash the images before removing vendor files
	# which "./vendor inject" uses for verification
	rm -f "${romdir}/vendorhashes" || $err "!rm ${romdir}/vendorhashes"
	touch "${romdir}/vendorhashes" || $err "!touch ${romdir}/vendorhashes"
	(
	cd "${romdir}" || $err "!cd romdir ${romdir}, nukerom"
	sha512sum ./*.rom >> vendorhashes || \
	    $err "!create vendorhashes, nukerom"
	) || $err "can't create vendor hashes"

	for romfile in "${romdir}"/*.rom; do
		[ -f "${romfile}" ] || continue
		./vendor inject -r "$romfile" -b "$target" -n nuke || \
		    $err "!vendor inject (nuke) ${romfile}, nukerom"
	done
}

insert_copying_files()
{
	remkdir "${1}/licenses"
	l="${1}/licenses"
	# copy licenses to rom image archive, for completion
	cp "src/grub/COPYING" "${l}/COPYING.grub" || return 1
	cp "src/coreboot/default/COPYING" "${l}/COPYING.coreboot" || return 1
	cp -R "src/coreboot/default/LICENSES" "${l}/LICENSES.coreboot" || \
	    return 1
	cp "src/seabios/default/COPYING" "${l}/COPYING.coreboot" || return 1
	cp "src/seabios/default/COPYING.LESSER" "$l/COPYING.LESSER.seabios" \
	    || return 1
	cp -R "src/u-boot/default/Licenses" "${l}/COPYING.u-boot" || return 1
	printf "Multiple licenses. Check corresponding %s source archive\n" \
	    "${projectname}" > "${1}/COPYING" || return 1
	rm -f src/u-boot/*/test/lib/strlcat.c || return 1
}

mkrom_tarball()
{
	archivename="${relname}_${target##*/}"
	f="release/${version}/roms/${archivename}"
	mkdir -p "${f%/*}" || $err "mkrom_tarball: !mkdir -p ${f%/*}"
	(
	cd "${romdir%"/bin/$target"}" || $err "!cd ${romdir%"/bin/$target"}"
	mktarball "bin/${target}" "${archivename}.tar.xz"
	) || $err "can't create rom tarball"
	mv "${romdir%"/bin/${target}"}/${archivename}.tar.xz"* "${f%/*}" || \
	    $err "mktar ${f%/*}/${romdir%"/bin/$target"}/$archivename.tar.xz"

	printf "Created ROM archive: %s" "${f%/*}/${archivename}.tar.xz"
}

insert_version_files()
{
	printf "%s\n" "${version}" > "${1}/version" || return 1
	printf "%s\n" "${versiondate}" > "${1}/versiondate" || return 1
	printf "%s\n" "${projectname}" > "${1}/projectname" || return 1
}

mktarball()
{
	# preserve timestamps for reproducible tarballs
	tar_implementation=$(tar --version | head -n1) || :

	[ "${2%/*}" = "${2}" ] || \
		mkdir -p "${2%/*}" || $err "mk, !mkdir -p \"${2%/*}\""
	printf "\nCreating archive: %s\n\n" "$2"
	if [ "${tar_implementation% *}" = "tar (GNU tar)" ]; then
		tar --sort=name --owner=root:0 --group=root:0 \
		    --mtime="UTC 2024-05-04" -c "$1" | xz -T$threads -9e \
		    > "$2" || $err "mktarball 1, ${1}"
	else
		# TODO: reproducible tarballs on non-GNU systems
		tar -c "$1" | xz -T$threads -9e > "$2" || \
		    $err "mktarball 2, $1"
	fi
	(
	[ "${2%/*}" != "${2}" ] && x_ cd "${2%/*}"
	sha512sum "${2##*/}" > "${2##*/}.sha512" || \
	    $err "!sha512sum \"${2##*/}\" > \"${2##*/}.sha512\""
	) || $err "failed to create tarball checksum"
}

mkversion()
{
	printf "revision: %s %s\n" "$projectname" "$version"
	printf "revision date: %s\n" "$(date -Rud @${versiondate})"
}

lbmk_exit()
{
	tmp_cleanup || err_ "lbmk_exit: can't rm tmpdir upon exit $1: $tmpdir"
	exit $1
}

fail()
{
	tmp_cleanup || printf "WARNING: can't rm tmpdir: %s\n" "$tmpdir" 1>&2
	err_ "${1}"
}

tmp_cleanup()
{
	[ "${tmpdir_was_set}" = "n" ] || return 0
	rm -Rf "${tmpdir}" || return 1
}

main $@
