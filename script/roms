#!/usr/bin/env sh
# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (c) 2014-2016,2020-2021,2023-2024 Leah Rowe <leah@libreboot.org>
# Copyright (c) 2021-2022 Ferass El Hafidi <vitali64pmemail@protonmail.com>
# Copyright (c) 2022 Caleb La Grange <thonkpeasant@protonmail.com>
# Copyright (c) 2022-2023 Alper Nebi Yasak <alpernebiyasak@gmail.com>
# Copyright (c) 2023 Riku Viitanen <riku.viitanen@protonmail.com>

set -u -e

. "include/lib.sh"

tmprom="$tmpdir/rom"

seavgabiosrom="elf/seabios/default/libgfxinit/vgabios.bin"
cfgsdir="config/coreboot"
rp2040src="src/pico-serprog"
rp2040x="$rp2040src/build/pico_serprog.uf2"
picosdk="src/pico-sdk"
rp2040dir="$picosdk/src/boards/include/boards"
stm32src="src/stm32-vserprog"
stm32x="$stm32src/stm32-vserprog.hex"
stm32dir="$stm32src/boards"

# Disable all payloads by default.
# target.cfg files have to specifically enable [a] payload(s)
pv="payload_uboot payload_seabios payload_memtest t payload_grub"
v="romdir initmode displaymode cbcfg targetdir tree release ubootelf"
v="$v board grub_scan_disk uboot_config grubtree grubelf tmpmv"
eval `setvars "n" $pv`
eval `setvars "" $v boards targets serdir ser`

main()
{
	while [ $# -gt 0 ]; do
		if [ "$1" = "serprog" ]; then
			[ $# -lt 2 ] && $err "serprog type not set"
			[ "$2" != "rp2040" ] && [ "$2" != "stm32" ] && \
			    $err "invalid serprog type"
			eval "x_ ./update trees -f \"\${${2}src##*/}\""
			ser="$2" && shift 2 && continue
		fi
		[ "$1$ser" = "list" ] && x_ ls -1 config/coreboot && return
		[ "$1" = "all" ] && shift && continue
		boards="$1 $boards"; shift 1
	done

	[ -n "$boards" ] || [ -n "$ser" ] || boards="$(ls -1 \
	    config/coreboot)" || $err "can't list coreboot boards"

	[ -n "$ser" ] && \
	    eval "serlist \"\$${ser}dir\" > \"\$tmpdir/ser\" || $err \"!ser\""
	[ -n "$ser" ] && [ -z "$boards" ] && boards="$(cat "$tmpdir/ser")"

	for x in $boards; do
		[ -n "$ser" ] && mkserprogfw "$ser" "$x"
		[ -z "$ser" ] && [ -d "config/coreboot/$x/config" ] && \
		    configure_target "$x" && build_roms && \
		    [ -d "bin/$board" ] && targets="$targets, $x"; continue
	done

	[ -n "$ser" ] && [ "$xbmk_release" = "y" ] && \
	    mkrom_tarball "bin/serprog_$ser" && return 0

	[ -z "$ser" ] && [ -z "$targets" ] && $err "No images were compiled"
	[ -z "$ser" ] && printf "ROMs built in bin/ for: %s\n" "${targets#, }"
	printf "Please flash from bin/, NOT elf/ - ALSO:\n%s\n" "$kbnotice"
}

mkserprogfw()
{
	x_ mkdir -p "bin/serprog_$1"
	[ "$1" = "rp2040" ] && x_ cmake -DPICO_BOARD="$2" \
	    -DPICO_SDK_PATH="$picosdk" -B "$rp2040src/build" "$rp2040src" && \
	    x_ cmake --build "$rp2040src/build"
	[ "$1" = "stm32" ] && x_ make -C "$stm32src" libopencm3-just-make \
	    BOARD=$2 && x_ make -C "$stm32src" BOARD=$2
	eval "x_ mv \"\$${1}x\" \"bin/serprog_$1/serprog_$2.\${${1}x##*.}\""
}

serlist()
{
	basename -a -s .h "$1/"*.h || $err "$1: can't list boards"
}

configure_target()
{
	eval `setvars "n" $pv`
	eval `setvars "" $v`

	board="$1"; targetdir="$cfgsdir/$board"; romdir="bin/$board"

	# Override the above defaults using target.cfg
	eval `setcfg "$targetdir/target.cfg"`
	x_ ./update trees -b coreboot $board

	[ -z "$tree" ] && $err "$board: tree not defined"
	[ "$xbmk_release" = "y" ] && [ "$release" = "n" ] && return 1
	[ "$board" = "$tree" ] && return 1

	cbdir="src/coreboot/$tree"
	cbfstool="elf/cbfstool/$tree/cbfstool"
	[ -f "$cbfstool" ] || x_ ./update trees -b coreboot utils $tree

	[ -n "$uboot_config" ] || uboot_config="default"
	[ "$payload_uboot" = "y" ] || payload_seabios="y"
	[ "$payload_grub" = "y" ] && payload_seabios="y"
	[ "$payload_seabios" = "y" ] && [ -n "$payload_uboot" = "y" ] && \
	    $err "$board: U-Boot and SeaBIOS/GRUB are both enabled."

	[ -z "$grub_scan_disk" ] && grub_scan_disk="nvme ahci ata"

	[ -n "$grubtree" ] || grubtree="default"
	grubelf="elf/grub/$grubtree/payload/grub.elf"

	[ "$payload_memtest" = "y" ] || payload_memtest="n"
	[ "$(uname -m)" = "x86_64" ] || payload_memtest="n"; return 0
}

build_roms()
{
	x_ rm -Rf "$romdir"

	for it in "normal" "vgarom" "libgfxinit"; do
		initmode="$it"; hmode="vesafb"
		[ "$initmode" = "vgarom" ] || hmode="corebootfb"
		modes="$hmode txtmode"
		for dt in $modes; do
			displaymode="$dt"; [ "$initmode" = "normal" ] && \
			    [ "$displaymode" != "txtmode" ] && continue
			cbcfg="$targetdir/config/${initmode}_$displaymode"
			[ "$initmode" = "normal" ] && cbcfg="${cbcfg%_*}"
			e "$cbcfg" f not || add_payloads; x_ rm -f "$tmprom"
		done
	done
}

add_payloads()
{
	cbuild="$cbelfdir/$board/${initmode}_$displaymode"
	[ "$initmode" = "normal" ] && cbuild="${cbuild%"_$displaymode"}"
	x_ cp "$cbuild/coreboot.rom" "$tmprom"

	[ "$payload_seabios" = "y" ] && add_seabios_payload
	[ "$payload_uboot" = "y" ] || return 0

	# add u-boot payload
	x_ ./update trees -b u-boot $board
	ubdir="elf/u-boot/$board/$uboot_config"
	ubootelf="$ubdir/u-boot.elf" && [ ! -f "$ubootelf" ] && \
	    ubootelf="$ubdir/u-boot"
	[ -f "$ubootelf" ] || $err "$board: Can't find u-boot"

	cbfs "$tmprom" "$ubootelf" "fallback/payload"
	cprom "$romdir/uboot_payload_${board}_${initmode}_$displaymode.rom"
}

add_seabios_payload()
{
	_seabioself="elf/seabios/default/$initmode/bios.bin.elf"
	x_ ./update trees -b seabios

	pstr="seabios" && [ "$payload_grub" = "y" ] && pstr="seabios_withgrub"
	newrom="$romdir/${pstr}_${board}_$initmode.rom"
	[ "$initmode" = "normal" ] || newrom="${newrom%.rom}_$displaymode.rom"

	cbfs "$tmprom" "$_seabioself" "fallback/payload"
	x_ "$cbfstool" "$tmprom" add-int -i 3000 -n etc/ps2-keyboard-spinup

	z="2"; [ "$initmode" = "vgarom" ] && z="0"
	x_ "$cbfstool" "$tmprom" add-int -i $z -n etc/pci-optionrom-exec
	x_ "$cbfstool" "$tmprom" add-int -i 0 -n etc/optionroms-checksum
	[ "$initmode" = "libgfxinit" ] && cbfs "$tmprom" "$seavgabiosrom" \
	    vgaroms/seavgabios.bin raw

	if [ "$payload_grub" = "y" ]; then
		x_ ./update trees -b grub $grubtree
		cbfs "$tmprom" "$grubelf" "img/grub2"
		printf "set grub_scan_disk=\"%s\"\n" "$grub_scan_disk" \
		    > "$tmpdir/tmpcfg" || $err "$board: !insert scandisk"
		cbfs "$tmprom" "$tmpdir/tmpcfg" scan.cfg raw
	fi

	[ "$payload_memtest" = "y" ] && x_ ./update trees -b memtest86plus && \
	    cbfs "$tmprom" "elf/memtest86plus/memtest.bin" img/memtest

	cprom "$newrom" && [ "$payload_grub" = "y" ] && \
	    cbfs "$tmprom" "$grubdata/bootorder" bootorder raw && \
	    cprom "${newrom%.rom}_grubfirst.rom"; return 0
}

cprom()
{
	printf "Creating target image: %s\n" "$1"
	x_ mkdir -p "${1%/*}"; x_ cp "$tmprom" "$1"
	[ "$xbmk_release" = "y" ] && mksha512sum "$1" "vendorhashes" && \
	    x_ ./vendor inject -r "$1" -b "$board" -n nuke; return 0
}

main $@
