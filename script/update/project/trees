#!/usr/bin/env sh
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2014-2016,2020,2021,2023 Leah Rowe <leah@libreboot.org>
# SPDX-FileCopyrightText: 2022 Alper Nebi Yasak <alpernebiyasak@gmail.com>
# SPDX-FileCopyrightText: 2022 Ferass El Hafidi <vitali64pmemail@protonmail.com>

[ "x${DEBUG+set}" = 'xset' ] && set -v
set -u -e

. "include/err.sh"
. "include/git.sh"
. "include/option.sh"

eval "$(setvars "" _target tree rev project cfgsdir)"

main()
{
	printf "Downloading %s and applying patches\n" ${project}

	[ -z "${1}" ] && err "project name not specified"
	project="${1}"
	cfgsdir="config/${project}"
	[ -d "${cfgsdir}" ] || err "unsupported project name"
	x_ rm -f "${cfgsdir}/"*/seen
	shift 1

	targets=$(listitems "${cfgsdir}")
	[ $# -gt 0 ] && targets=$@
	[ -z "${targets}" ] && \
	    err "No targets available for project: ${project}"

	for x in ${targets}; do
		x_ rm -f "${cfgsdir}"/*/seen
		x_ download_for_target "${x}"
	done
	x_ rm -f "${cfgsdir}"/*/seen
}

download_for_target()
{
	_target="${1}"
	tree="undefined"
	rev="undefined"

	x_ fetch_config "${_target}"
	x_ rm -f "${cfgsdir}"/*/seen

	if [ -d "${project}/${tree}" ]; then
		printf "REMARK: download/%s %s: exists. Skipping.\n" \
		    "${project}" "${tree}" 1>&2
		[ "${tree}" != "${_target}" ] && \
			printf "(for target: '%s}')\n" "${_target}" 1>&2
		return 0
	fi

	fetch_from_upstream || \
	    err "download_for_target: cannot fetch: ${project}"
	x_ prepare_new_tree "${_target}" "${tree}" "${rev}"
}

fetch_config()
{
	_target=${1}

	while true; do
		rev="undefined"
		tree="undefined"

		check_config_for_target "${_target}" || return 1

		# This is to override $rev and $tree
		. "${cfgsdir}/${_target}/target.cfg" || \
		    err "fetch_config: no \"${cfgsdir}/${_target}/target.cfg\""

		if [ "${_target}" != "${tree}" ]; then
			_target="${tree}"
			continue
		elif [ "${tree}" = "undefined" ]; then
			printf "ERROR (fetch_config): download/%s:" \
			    "${project}" 1>&2
			printf " tree name undefined for '%s\n'" \
			    "${_target}" 1>&2
			return 1
		elif [ "${rev}" = "undefined" ]; then
			printf "ERROR (fetch_config): download/%s:" \
			    "${project}" 1>&2
			printf " commit ID undefined for '%s'\n" \
			    "${_target}" 1>&2
			return 1
		else
			break
		fi
	done
}

check_config_for_target()
{
	_target=${1}

	if [ ! -f "${cfgsdir}/${_target}/target.cfg" ]; then
		printf "ERROR: download/%s: target.cfg does not" \
		    "${project}" 1>&2
		printf " exist for '%s'\n" "${_target}" 1>&2
		return 1
	elif [ -f "${cfgsdir}/${_target}/seen" ]; then
		printf "ERROR: download/%s: logical loop:" "${project}" 1>&2
		printf " '%s' target.cfg refers to another tree," "${_target}" \
		    1>&2
		printf " which ultimately refers back to '%s'." "${_target}" \
		    1>&2
		return 1
	fi
	x_ touch "${cfgsdir}/${_target}/seen"
}

fetch_from_upstream()
{
	[ -d "${project}" ] || mkdir -p "${project}" || return 1
	[ -d "${project}" ] || return 1
	[ -d "${project}/${project}" ] && return 0

	./update project repo ${project} || return 1
}

prepare_new_tree()
{
	target=${1}
	tree=${2}
	rev=${3}

	printf "Preparing %s tree: %s\n" ${project} ${tree}
	[ "${tree}" != "${target}" ] && \
		printf "(for target, %s)\n" "${target}"

	x_ cp -R "${project}/${project}" "${project}/${tree}"
	x_ git_reset_rev "${project}/${tree}" "${rev}" "err"

	(
	x_ cd "${project}/${tree}"
	git submodule update --init --checkout || \
	    err "prepare_new_tree ${project}/${tree}: can't update git modules"
	)

	x_ git_am_patches "${PWD}/${project}/${tree}" \
	    "${PWD}/${cfgsdir}/${tree}/patches" "err"
}

main $@
