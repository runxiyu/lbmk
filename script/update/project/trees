#!/usr/bin/env sh
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2014-2016,2020,2021,2023 Leah Rowe <leah@libreboot.org>
# SPDX-FileCopyrightText: 2022 Alper Nebi Yasak <alpernebiyasak@gmail.com>
# SPDX-FileCopyrightText: 2022 Ferass El Hafidi <vitali64pmemail@protonmail.com>

[ "x${DEBUG+set}" = 'xset' ] && set -v
set -u -e

. "include/err.sh"
. "include/git.sh"
. "include/option.sh"

eval "$(setvars "" _target tree rev project cfgsdir _xm)"

main()
{
	printf "Downloading %s and applying patches\n" ${project}

	[ -z "${1}" ] && err "project name not specified"
	project="${1}" && shift 1

	configure_targets $@

	for x in ${targets}; do
		x_ rm -f "${cfgsdir}/"*/seen
		download_for_target "${x}"
	done
}

configure_targets()
{
	cfgsdir="config/${project}"
	[ -d "${cfgsdir}" ] || err "unsupported project name"

	targets=$(listitems "${cfgsdir}")
	[ $# -gt 0 ] && targets=$@
	[ -z "${targets}" ] || return 0

	err "No targets for project: ${project}"
}

download_for_target()
{
	_target="${1}"
	tree="undefined"
	rev="undefined"

	fetch_config
	[ -d "${project}/${tree}" ] && printf "download/%s %s (%s): exists\n" \
	    "${project}" "${tree}" "${_target}" 1>&2 && return 0

	fetch_from_upstream
	prepare_new_tree
}

fetch_config()
{
	while true; do
		eval "$(setvars "" rev tree)"
		_xm="fetch_config ${project}/${_target}"

		check_config_for_target "${_target}"

		# This is to override $rev and $tree
		. "${cfgsdir}/${_target}/target.cfg" || \
		    err "fetch_config: no \"${cfgsdir}/${_target}/target.cfg\""

		[ "${_target}" != "${tree}" ] && _target="${tree}" && continue
		[ -z ${tree} ] && err "${_xm}: tree undefined"
		[ -z ${rev} ] && err "${_xm}: revision undefined"
		break
	done
}

check_config_for_target()
{
	[ -f "${cfgsdir}/${1}/target.cfg" ] || \
		err "${_xm} check: target.cfg does not exist"
	[ -f "${cfgsdir}/${1}/seen" ] && \
		err "${_xm} check: infinite loop in tree definitions"

	x_ touch "${cfgsdir}/${1}/seen"
}

fetch_from_upstream()
{
	[ -d "${project}" ] || x_ mkdir -p "${project}"
	[ -d "${project}/${project}" ] && return 0

	x_ ./update project repo "${project}"
}

prepare_new_tree()
{
	printf "Creating %s tree %s (%s)\n" "${project}" "${tree}" "${_target}"

	x_ cp -R "${project}/${project}" "${project}/${tree}"
	x_ git_reset_rev "${project}/${tree}" "${rev}" "err"
	(
	x_ cd "${project}/${tree}"
	git submodule update --init --checkout || \
	    err "prepare_new_tree ${project}/${tree}: can't update git modules"
	)
	git_am_patches "${PWD}/${project}/${tree}" \
	    "${PWD}/${cfgsdir}/${tree}/patches" "err"
}

main $@
