#!/usr/bin/env sh
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2020-2023 Leah Rowe <leah@libreboot.org>

[ "x${DEBUG+set}" = 'xset' ] && set -v
set -u -e

. "include/err.sh"
. "include/option.sh"

eval "$(setvars "" vdir relname src_dirname srcdir _xm target romdir \
    microcode_required mode)"

main()
{
	vdir="release"
	while getopts d:m: option; do
		[ -z "${OPTARG}" ] && err "Empty argument not allowed"
		case "${option}" in
		d) vdir="${OPTARG}" ;;
		m) mode="${OPTARG}" ;;
		*) err "Invalid option" ;;
		esac
	done

	vdir="${vdir}/${version}"
	relname="${projectname}-${version}"
	src_dirname="${relname}_src"
	srcdir="${vdir}/${src_dirname}"

	[ -e "${vdir}" ] && err "already exists: \"${vdir}\""

	mkvdir
	build_release

	printf "DONE! Check release files under %s\n" "${vdir}"
}

mkvdir()
{
	mkdir -p "${vdir}" || err "mkvdir: !mkdir -p \"${vdir}\""
	git clone . "${srcdir}" || err "mkdir: !gitclone \"${srcdir}\""
	insert_version_files "${srcdir}" || err "mkvdir ${srcdir}: versionfile"
}

build_release()
{
	_xm="build_release ${vdir}"
	(
	cd "${srcdir}" || err "${_xm}: !cd \"${srcdir}\""
	fetch_trees
	)
	(
	cd "${srcdir%/*}" || err "${_xm}: mktarball \"${srcdir}\""
	mktarball "${srcdir##*/}" "${srcdir##*/}.tar.xz" || err "${_xm}: mksrc"
	)
	[ "${mode}" = "src" ] && return 0 # for src mode, xgcc tarballs are
					  # not included in the src archive

	# now build roms, then copy crossgcc to src and re-compress
	# while compressing rom images too.

	(
	cd "${srcdir}" || err "${_xm}: 2 !cd \"${srcdir}\""
	mkrom_images
	)
	for _cbd in "${srcdir}/src/coreboot/"*; do
		[ -d "${_cbd}/util/crossgcc/tarballs" ] || continue
		_xgccdir="${vdir}/crossgcc/${_cbd##*/}"
		mkdir -p "${_xgccdir}" || \
		    err "build_release: !mkdir -p ${_xgccdir}"
		cp -R "${_cbd}/util/crossgcc/tarballs/"* "${_xgccdir}" || \
		    err "build_gcc: !copy xgcc ${_cbd}"
	done
	rm -Rf "${srcdir}" || err "build_release: !rm -Rf ${srcdir}"
	(
	cd "${srcdir%/*}" || err "${_xm} 2: mktarball \"${srcdir}\""
	tar -xf "${srcdir##*/}.tar.xz" || err "!extract ${srcdir##*/}.tar.xz"
	rm -f "${srcdir##*/}.tar.xz" || err "!rm -f ${srcdir##*/}.tar.xz"
	)
	for _xgcc in "${vdir}/crossgcc/"*; do
		[ -d "${_xgcc}" ] || continue
		mkdir -p "${srcdir}/src/coreboot/${_xgcc##*/}/util/crossgcc/tarballs" || \
		    err "!mkdir src/coreboot/${_xgcc##*/}/util/crossgcc/tarballs"
		mv "${_xgcc}/"* \
		    "${srcdir}/src/coreboot/${_xgcc##*/}/util/crossgcc/tarballs/" \
		    || err "!move xgcc tarballs to ${srcdir}/xgcc/${_xgcc##*/}"
	done
	rm -Rf "${vdir}/crossgcc" || err "!rm -Rf \"${vdir}/crossgcc\""
	(
	cd "${srcdir%/*}" || err "${_xm}: mktarball \"${srcdir}\""
	mktarball "${srcdir##*/}" "${srcdir##*/}.tar.xz" || err "${_xm}: mksrc"
	)

	# now test the vendor insert script, using the release archive:
	(
	cd "${srcdir}" || err "!cd ${srcdir}"
	for vrom in ../roms/*.tar.xz; do
		[ -f "${vrom}" ] || continue
		case "${vrom}" in
		*serprog*) continue ;;
		esac
		./vendor inject "${vrom}" || \
		    err "TESTFAIL: inject: ${vrom##*/}"
		continue
	done
	)

	rm -Rf "${srcdir}" || err "!rm -Rf ${srcdir}"
}

fetch_trees()
{
	for x in config/git/*; do
		[ ! -f "${x}" ] || ./update trees -f "${x#config/git/}" || \
		    err "${_xm}: fetch ${x#config/git/}"
	done
	for x in config/*/build.list; do
		[ -f "${x}" ] || continue
		xp="${x#*/}"; xp="${xp%/*}"
		[ -L "${xp}" ] || x_ rm -Rf "src/${xp}/${xp}"
	done

	find . -name ".git" -exec rm -Rf {} + || err "${_xm}: rm .git"
	find . -name ".gitmodules" -exec rm -Rf {} + || err "${_xm}: rm .gitmod"
	x_ rm -Rf tmp .git
}

mkrom_images()
{
	./build roms all || err "${_xm}: roms-all"
	./build serprog rp2040 || err "${_xm}: rp2040"
	./build serprog stm32 || err "${_xm}: stm32"

	for rombuild in bin/*; do
		[ -d "${rombuild}" ] || continue
		handle_rom_archive "${rombuild}"
	done

	mv "release/${version}/roms/" ../roms || err "${_xm}: copy roms/"
}

handle_rom_archive()
{
	builddir="${1}"
	romdir="tmp/romdir"
	x_ rm -Rf "${romdir}"
	target="${builddir##*/}"

	if [ ! -f "config/coreboot/${target}/target.cfg" ]; then
		# No config, just make a tarball
		tarball="release/${version}/roms/${relname}_${target}.tar.xz"
		insert_copying_files "${builddir}"
		mktarball "${builddir}" "${tarball}"
		return 0
	fi

	romdir="${romdir}/bin/${target}"
	x_ mkdir -p "${romdir}"
	x_ cp "${builddir}/"* "${romdir}"

	nukerom

	printf "Generating release/%s/roms/%s-%s_%s.tar.xz\n" \
	    "${version}" "${projectname}" "${version}" "${target##*/}"
	insert_version_files "${romdir}" || \
	    err "mkrom_tarball ${romdir}: versionfile"

	insert_copying_files "${romdir}"
	mkrom_tarball
}

nukerom()
{
	microcode_required="y"
	. "config/coreboot/${target}/target.cfg"
	if [ "${microcode_required}" != "y" ] && \
	    [ "${microcode_required}" != "n" ]; then microcode_required="y"; fi
	if [ "${microcode_required}" = "n" ]; then
		for romfile in "${romdir}"/*.rom; do
			[ -f "${romfile}" ] || continue
			strip_ucode "${romfile}"
		done
		for romfile in "${romdir}"/*.tmprom; do
			[ -f "${romfile}" ] || continue
			x_ mv "${romfile}" "${romfile%.tmprom}.rom"
		done
	fi

	# Hash the images before removing vendor files
	# which "./vendor inject" uses for verification
	x_ rm -f "${romdir}/vendorhashes"
	x_ touch "${romdir}/vendorhashes"
	(
	x_ cd "${romdir}"
	x_ sha512sum *.rom >> vendorhashes
	)

	for romfile in "${romdir}"/*.rom; do
		[ -f "${romfile}" ] || continue
		x_ ./vendor inject -r "${romfile}" -b ${target} -n nuke
	done
}

strip_ucode()
{
	romfile=${1}
	_newrom_b="${romfile%.rom}_nomicrocode.tmprom"
	x_ cp "${romfile}" "${_newrom_b}"
	microcode_present="y"
	"${cbfstool}" "${_newrom_b}" remove -n \
	    cpu_microcode_blob.bin 2>/dev/null || microcode_present="n"
	[ "${microcode_present}" = "n" ] || return 0
	printf "REMARK: '%s' already lacks microcode\n" "${romfile}" 1>&2
	printf "Renaming default ROM file instead.\n" 1>&2
	x_ mv "${romfile}" "${_newrom_b}"
}

insert_copying_files()
{
	x_ rm -Rf "${1}/licenses"
	x_ mkdir -p "${1}/licenses"
	l="${1}/licenses"
	# copy licenses to rom image archive, for completion
	x_ cp "src/grub/COPYING" "${l}/COPYING.grub"
	x_ cp "src/coreboot/default/COPYING" "${l}/COPYING.coreboot"
	x_ cp -R "src/coreboot/default/LICENSES" "${l}/LICENSES.coreboot"
	x_ cp "src/seabios/default/COPYING" "${l}/COPYING.coreboot"
	x_ cp "src/seabios/default/COPYING.LESSER" "${l}/COPYING.LESSER.seabios"
	x_ cp -R "src/u-boot/default/Licenses" "${l}/COPYING.u-boot"
	x_ printf "Multiple licenses. Check corresponding %s source archive\n" \
	    "${projectname}" > "${1}/COPYING"
}

mkrom_tarball()
{
	archivename="${relname}_${target##*/}"
	f="release/${version}/roms/${archivename}"
	x_ mkdir -p "${f%/*}"
	(
	x_ cd "${romdir%/bin/${target}}"
	mktarball "bin/${target}" "${archivename}.tar.xz"
	)
	x_ mv "${romdir%/bin/${target}}/${archivename}.tar.xz"* "${f%/*}"

	printf "Created ROM archive: ${f%/*}/${archivename}.tar.xz"
}

insert_version_files()
{
	printf "%s\n" "${version}" > "${1}/version" || return 1
	printf "%s\n" "${versiondate}" > "${1}/versiondate" || return 1
	printf "%s\n" "${projectname}" > "${1}/projectname" || return 1
}

mktarball()
{
	# preserve timestamps for reproducible tarballs
	tar_implementation=$(tar --version | head -n1) || :

	[ "${2%/*}" = "${2}" ] || x_ mkdir -p "${2%/*}"
	if [ "${tar_implementation% *}" = "tar (GNU tar)" ]; then
		tar --sort=name --owner=root:0 --group=root:0 \
		    --mtime="UTC 2023-10-21" -c "${1}" | xz -T0 -9e > "${2}" || \
		    err "mktarball 1, ${1}"
	else
		# TODO: reproducible tarballs on non-GNU systems
		tar -c "${1}" | xz -T0 -9e > "${2}" || err "mktarball 2, ${1}"
	fi
	(
	[ "${2%/*}" != "${2}" ] && x_ cd "${2%/*}"
	x_ sha512sum "${2##*/}" > "${2##*/}.sha512"
	)
}

main $@
